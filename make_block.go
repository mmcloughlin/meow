// +build ignore

package main

import (
	"crypto/aes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

const BlockSize = 256

var output = flag.String("out", "block_amd64.s", "output filename")

func main() {
	flag.Parse()
	f, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	m := NewMeow(f)
	if err := m.Generate(); err != nil {
		log.Fatal(err)
	}
}

type Array struct {
	Base   string
	Offset int
}

func (a Array) Addr(idx int) string {
	return fmt.Sprintf("%d(%s)", a.Offset+idx, a.Base)
}

type StackFrame struct {
	Size int
}

func (s *StackFrame) Alloc(size int) Array {
	a := Array{Base: "SP", Offset: s.Size}
	s.Size += size
	return a
}

// Meow writes an assembly implementation of Meow hash components.
type Meow struct {
	w   io.Writer // where to write assembly output
	err error     // saved error from writing
}

// NewMeow builds a new assembly builder writing to w.
func NewMeow(w io.Writer) *Meow {
	return &Meow{
		w: w,
	}
}

// Generate triggers assembly generation.
func (m *Meow) Generate() error {
	m.header()
	m.sum()
	return m.err
}

// sum outputs the entire checksum function.
func (m *Meow) sum() {
	frame := StackFrame{}
	streams := frame.Alloc(BlockSize)
	partial := frame.Alloc(BlockSize)
	iv := frame.Alloc(16)

	m.text("sum", frame.Size, 40)

	m.arg("seed", 0, "R8")
	m.arg("dst_ptr", 8, "DI")
	m.arg("src_ptr", 16, "SI")
	m.arg("src_len", 24, "AX")

	m.section("Prepare IV.")
	m.alloc("IV", "R9")
	m.inst("MOVQ", "SEED, IV")
	m.inst("MOVQ", "IV, %s", iv.Addr(0))
	m.inst("ADDQ", "SRC_LEN, IV")
	m.inst("INCQ", "IV")
	m.inst("MOVQ", "IV, %s", iv.Addr(8))

	m.section("Load IV.")
	m.inst("MOVOU", "%s, X0", iv.Addr(0))
	for i := 0; i < 16; i++ {
		m.inst("MOVOU", "X0, %s", streams.Addr(16*i))
	}

	m.blockloop(streams, "partial")

	m.label("partial")
	m.inst("CMPQ", "SRC_LEN, $0")
	m.inst("JE", "finish")

	m.section("Load IV into partial block.")
	m.inst("MOVOU", "%s, X0", iv.Addr(0))
	for i := 0; i < 16; i++ {
		m.inst("MOVOU", "X0, %s", partial.Addr(16*i))
	}

	m.alloc("BLOCK_PTR", "BX")
	m.inst("LEAQ", "%s, BLOCK_PTR", partial.Addr(0))
	m.label("byteloop")
	m.inst("MOVB", "(SRC_PTR), R10")
	m.inst("MOVB", "R10, (BLOCK_PTR)")
	m.inst("INCQ", "SRC_PTR")
	m.inst("INCQ", "BLOCK_PTR")
	m.inst("DECQ", "SRC_LEN")
	m.inst("JNE", "byteloop")

	m.aesdecblock(streams, partial)

	m.label("finish")

	m.section("Load IV into R0.")
	for i := 0; i < 4; i++ {
		m.inst("MOVOU", "%s, X%d", iv.Addr(0), i)
	}

	for r := 0; r < 4; r++ {
		m.section(fmt.Sprintf("Rotation block %d.", r))
		for i := 0; i < 4; i++ {
			for j := 0; j < 4; j++ {
				idx := 4*i + (j+r)%4
				m.inst("MOVOU", "%s, X%d", streams.Addr(16*idx), j+8)
				m.inst("AESDEC", "X%d, X%d", j+8, j)
			}
		}
	}

	m.section("Final merge.")
	m.inst("MOVOU", "%s, X8", iv.Addr(0))
	for i := 0; i < 5; i++ {
		for j := 0; j < 4; j++ {
			m.inst("AESDEC", "X8, X%d", j)
		}
	}

	m.section("Store hash.")
	for i := 0; i < 4; i++ {
		m.inst("MOVOU", "X%d, %d(DST_PTR)", i, 16*i)
	}

	m.inst("RET", "")
}

func (m *Meow) aesdecblock(streams, merge Array) {
	for i := 0; i < BlockSize; i += aes.BlockSize {
		j := (i / aes.BlockSize) % 8
		m.inst("MOVOU", "%s, X%d", streams.Addr(i), j)
		m.inst("MOVOU", "%s, X%d", merge.Addr(i), j+8)
		m.inst("AESDEC", "X%d, X%d", j+8, j)
		m.inst("MOVOU", "X%d, %s", j, streams.Addr(i))
	}
}

// blockloop outputs a loop to encrypt entire blocks, exiting to the provided label.
func (m *Meow) blockloop(streams Array, exit string) {
	m.label("loop")
	m.inst("CMPQ", "SRC_LEN, $%d", BlockSize)
	m.inst("JL", exit)

	m.section("Hash block.")
	for i := 0; i < BlockSize; i += aes.BlockSize {
		j := (i / aes.BlockSize) % 8
		m.inst("MOVOU", "%d(SRC_PTR), X%d", i, j)
		m.inst("MOVOU", "%s, X%d", streams.Addr(i), j+8)
		m.inst("AESDEC", "X%d, X%d", j, j+8)
		m.inst("MOVOU", "X%d, %s", j+8, streams.Addr(i))
	}

	m.section("Update source pointer.")
	m.inst("ADDQ", "$%d, SRC_PTR", BlockSize)
	m.inst("SUBQ", "$%d, SRC_LEN", BlockSize)
	m.inst("JMP", "loop")
}

// header outputs the file header with code generation warning and standard header includes.
func (m *Meow) header() {
	_, self, _, _ := runtime.Caller(0)
	m.printf("// Code generated by go run %s. DO NOT EDIT.\n\n", filepath.Base(self))
	m.printf("#include \"textflag.h\"\n")
}

// section marks a section of the code with a comment.
func (m *Meow) section(description string) {
	m.printf("\n\t// %s\n", description)
}

// label defines a label.
func (m *Meow) label(name string) {
	m.printf("\n%s:\n", name)
}

// text defines a function header.
func (m *Meow) text(name string, frame, args int) {
	m.printf("\nTEXT \u00b7%s(SB),0,$%d-%d\n", name, frame, args)
}

// alloc informally "allocates" a register with a #define statement.
func (m *Meow) alloc(name, reg string) string {
	macro := strings.ToUpper(name)
	m.printf("#define %s %s\n", macro, reg)
	return macro
}

// arg reads an argument, and allocates a register for it.
func (m *Meow) arg(name string, offset int, reg string) {
	macro := m.alloc(name, reg)
	m.inst("MOVQ", "%s+%d(FP), %s", name, offset, macro)
}

// inst writes an instruction.
func (m *Meow) inst(name, format string, args ...interface{}) {
	args = append([]interface{}{name}, args...)
	m.printf("\t%-8s "+format+"\n", args...)
}
func (m *Meow) printf(format string, args ...interface{}) {
	if _, err := fmt.Fprintf(m.w, format, args...); err != nil {
		m.err = err
	}
}
